#!/usr/bin/env python
# Copyright 2013 The Mozilla Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
This script takes the data in controllers.json and mappings.json and
outputs a C++ header file containing a data table suitable for
remapping gamepad input in a C++ program.

Usage: writemappings.py <mappings.json> <output header.h>
"""

import json
import sys
from operator import itemgetter
from collections import defaultdict
from itertools import chain

file_template = """
/* Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/
 *
 * This file was autogenerated using writemappings.py.
 * TODO: put in revision information of source data
 */
#ifndef _GAMEPAD_MAPPING_DATA_H_
#define _GAMEPAD_MAPPING_DATA_H_

#include <sys/types.h>

const gamepad_mapping mappings[] = {
#ifdef __linux__%(linux)s
#endif /* __linux__ */
};
const size_t kNumMappings = sizeof(mappings) / sizeof(mappings[0]);

#endif /* _GAMEPAD_MAPPING_DATA_H_ */
"""

kStandardButtons = 17
buttons_template = "{%s}" % ",".join("{ %d, {{ %d, %d }} }" for x in range(kStandardButtons))
axes_template = "{%d, %d, %d, %d}"
entry_template = """
{"%(driver)s",
 0x%(vendor_id)04x,
 0x%(product_id)04x,
 %(buttons)s,
 %(axes)s
}"""

def process_buttons(obj, *args):
    """
    Each arg in args is a tuple of nested properties used to get a property
    from obj.
    Each arg in args yields three values representing the type of mapping,
    and either the button and axis mapped to this standard gamepad button or
    the hat switch mapped to this standard gamepad button.
    If the properties are not present then -1 will be yielded for all
    three values.
    """
    for arg in args:
        try:
            thing = obj
            for p in arg:
                thing = thing[p]
            b = thing
            # kButtonOrAxis
            yield 0
            if isinstance(b, int):
                # Just treat it as a button mapping.
                yield b
                yield -1
            else:
                if "button" in b:
                    yield b["button"]
                else:
                    yield -1
                if "axis" in b:
                    yield b["axis"]
                else:
                    yield -1
        except (KeyError, IndexError):
            # kUnmapped
            yield -1
            yield -1
            yield -1

def process_dpad_axes(dpad):
    for i, d in enumerate(["up", "down", "left", "right"]):
        # kHalfAxis
        yield 1
        # half_axis
        yield dpad[d]["axis"]
        # direction
        # up and left are negative, down and right are positive
        yield i % 2

def main(args):
    data = json.loads(open(args[0], "r").read())
    mappings = defaultdict(list)
    for m in sorted(data['mappings'], key=itemgetter("os",
                                                     "vendor_id",
                                                     "product_id",
                                                     "driver")):
        b = m["buttons"]
        # Face/shoulder/control buttons
        button_list = list(process_buttons(b,
                                           ("face", 0),
                                           ("face", 1),
                                           ("face", 2),
                                           ("face", 3),
                                           ("left_shoulder", 0),
                                           ("right_shoulder", 0),
                                           ("left_shoulder", 1),
                                           ("right_shoulder", 1),
                                           ("control", 0),
                                           ("control", 1),
                                           ))
        # Analog stick presses
        button_list.extend(process_buttons(m["sticks"],
                                           (0, "press"),
                                           (1, "press")
                                           ))
        # d-pad
        dpad = False
        if m["d-pads"]:
            if m["d-pads"][0]["type"] == "buttons":
                dpad = True
                button_list.extend(process_buttons(m["d-pads"][0],
                                                   ("up",),
                                                   ("down",),
                                                   ("left",),
                                                   ("right",)
                                                   ))
            elif m["d-pads"][0]["type"] == "axes":
                dpad = True
                button_list.extend(process_dpad_axes(m["d-pads"][0]))
        if not dpad:
            # no d-pad, apparently
            button_list.extend([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])
        # Last control button
        button_list.extend(process_buttons(b,("control", 2)))
        buttons = buttons_template % tuple(button_list)

        # Handle analog sticks
        if m["sticks"]:
            axis_list = [m["sticks"][0]["x"], m["sticks"][0]["y"]]
            if len(m["sticks"]) > 1:
                axis_list.extend([m["sticks"][1]["x"], m["sticks"][1]["y"]])
        else:
            # No sticks
            axis_list = [-1, -1, -1, -1]
        axes = axes_template % tuple(axis_list)
        entry = entry_template % {
            "driver": m["driver"],
            "vendor_id": int(m["vendor_id"], 16),
            "product_id": int(m["product_id"], 16),
            "buttons": buttons,
            "axes": axes
            }
        mappings[m["os"]].append(entry)
    with open(args[1], 'wb') as out:
        out.write(file_template %
                  dict((k, ",".join(v)) for k,v in mappings.iteritems()))

if __name__ == '__main__':
    main(sys.argv[1:])

